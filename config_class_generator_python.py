import yaml
import argparse
import os

TAB = "    "
NEW_LINE = "\n"


def BuildParamTemplateFileFromConfig(config_file: str, output_file: str) -> str:
    with open(config_file, "r") as f :
        param_dict = yaml.load(f, Loader=yaml.CLoader)
        return f"""# THIS DOCUMENT IS AUTOGENERATED BY THE CONFIGURATION MAKER PACKAGE.
# IT IS PROVIDED AS IS, DO NOT MODIFY

import yaml
import os
from dataclasses import dataclass

def EvalExpression(e):
    if(type(e) == list):
        return [EvalExpression(elt) for elt in e]
    res = str(e)
    try:
        res = eval(res)
    except:
        pass
    return res
{ParameterClassFromDict("ConfigurationSet", param_dict)}
    @classmethod
    def FromFile(cls, config_file: str):
        with open(config_file, "r") as f :
            param_dict = yaml.load(f, Loader=yaml.CLoader)
            return cls._fromDict(param_dict)

config = _ConfigurationSet.FromFile(os.path.join(os.path.dirname(__file__), "{os.path.relpath(config_file, os.path.dirname(output_file))}"))
"""

def ParameterClassFromDict(name: str, param_dict: dict, parent_class: str = ""):
    class_name = ClassName(name, parent_class)
    variables, subsections = AnalyzeDict(param_dict)
    subclasses = [ParameterClassFromDict(v, s[v], class_name) for s in subsections for v in s]

    subclasses_instances_variables = [f"{v.lower()}: {ClassName(v, class_name)}" for s in subsections for v in s]
    regular_variables = [Variable(v, type(EvalExpression(variables[v]))) for v in variables]
    
    load_subclasses = [f"{ClassName(v, class_name)}._fromDict(param_dict['{v}'])" for s in subsections for v in s]
    load_variables = [f"EvalExpression(param_dict['{v}'])" for v in variables]
    return f"""{"".join(subclasses)}
@dataclass
class {class_name}:
    {(NEW_LINE + TAB).join(subclasses_instances_variables + regular_variables)}
    @classmethod
    def _fromDict(cls, param_dict: dict):
        return cls(
            {f',{NEW_LINE + TAB*3}'.join(load_subclasses + load_variables)}
            )
"""

def ClassName(name: str, parent: str) -> str:
    return parent + '_' + name[0].upper() + name[1:]

def Variable(v: str, t: type) -> str:
    return v.lower() + ': ' + str(t).split("'")[1]

def EvalExpression(e):
    if(type(e) == list):
        return [EvalExpression(elt) for elt in e]
    res = str(e)
    try:
        res = eval(res)
    except:
        pass
    return res

def AnalyzeDict(d: dict):
    variables = {}
    subdicts = []
    for key in d:
        if(type(d[key]) == dict):
            subdicts.append({key: d[key]})
        else:
            variables[key] = d[key]
    return variables, subdicts


def main(config_file: str, output_file: str):
    with open(output_file, "w") as out:
        out.write(BuildParamTemplateFileFromConfig(config_file, output_file))


if __name__ == "__main__":
    arg_fmt = argparse.ArgumentDefaultsHelpFormatter
    parser = argparse.ArgumentParser(formatter_class=arg_fmt, description="This is a utility script to automatically generate a configuration class from a YAML config file.")
    parser.add_argument('config_file', help="Path of the configuration file to use")
    parser.add_argument('-o', '--output_file', help="Full path of the generated file")
    args = parser.parse_args()

    config_file = args.config_file
    if(not os.path.exists(config_file)):
        print("Input file not found")
        exit(-1)
    
    output_file = args.output_file
    if(output_file is None):
        config_file_dir = os.path.dirname(config_file)
        output_file = os.path.join(config_file_dir, "ConfigSet.py")

    if(not output_file.endswith(".py")):
        output_file += ".py"

    if(os.path.exists(output_file)):
        ok = input("Output file already exists. Override it ? [Y/n]")
        if(ok.upper() in ['N', 'NO']):
            exit(-1)

    main(config_file, output_file)